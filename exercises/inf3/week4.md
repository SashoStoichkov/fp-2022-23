Седмица 4
=========

Теория:
-------

- Какво са двойки
- Примерна реализация на двойки използвайки функции
- Какво са списъците и как да ги използваме

### Какво са двойки
До момента сме разглеждали няколко типа в Scheme - boolean, number & procedure като за реализиране на абстракция използвахме функции

Двойките са съставен тип данни, който реализира наредени двойки (както в математиката).

Двойки се създават чрез cons

```Racket
(cons 1 3) ; Наредената двойка (1 . 3)
(cons 5 8) ; Наредената двойка (5 . 8)
(cons 5 (cons 2 3)) ; Наредена двойка с първи елемент 5 и втори елемент наредена двойка (2 . 3), т.е. (5 . (2 . 3))
``` 

Можем да достъпим елемент на наредена двойка използвайки 
- `car` - връща първия елемент от наредената двойка
- `cdr` - връща втория елемент от наредената двойка

```Racket
(car (cons 5 3)) ; 5
(cdr (cons 8 2)) ; 2
(car (cdr (cons 3 (cons 6 7)))) ; 6 
```

За случаи като последния има и shortcut-и:
- `(cadr x)` ≡ `(car (cdr x))`
- `(cddr x)` ≡ `(cdr (cdr x))`
- `(caaar x)` ≡ `(car (car (car x)))`
- ...
Подобни shortcut-и са дефинирани до дълбочина 4, т.е. `caaddr` и подобни

### Примерна реализация на двойки използвайки функции
Въпреки че Scheme ни предоставя функциите за работа с наредени двойки наготово, полезно упражнение е да видим как бихме могли да ги реализираме.

Идея: Дефинираме cons като функция от по-висок ред, чийто резултат е функция, която приема 1 аргумент - коя компонента от наредената двойка искаме
```Racket
(define (cons x y)
  (lambda (m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Undefined behavior"))
    )
  )
)

(define (car z) (z 0))
(define (cdr z) (z 1))
```
[Защо това работи?](https://learn.fmi.uni-sofia.bg/mod/url/view.php?id=253586). На кратко - средите ни позволяват да "хванем" стойностите на x & y


Друга идея: Вместо ламбдата, която cons връща, да приема число, което да ни каже коя компонента да достъпим, можем да го направим процедура, която приема два аргумента - елементите на наредената двойка, и връща който от двата искаме
```Racket
(define (cons x y)
  (lambda (m) (m x y))
)

(define (car z) 
  (z (lambda (x y) x))
)

(define (cdr z)
  (z (lambda (x y) y))
)
```

Със сигурност може да се измислят и още варианти за реализацията на cons, но каква е важната поука - с ламбда можем да постигнем всякакъв вид абстракция.

Списъци
-------
Списъците в Scheme се ограждат в скоби, а стойностите се разделят с интервал

```Racket
(1 2 3 4)
(#t #f #f)
(2 #t 8 (lambda (y) (+ y 3)) 3.14)
```

Защо обаче списъците изглеждат като прилагане на функция? Защото прилагането на функция е списък. 
 
Ако се опитаме да създадем списък (1 2 3 4), интерпретатора ще ни се скара, че се опитваме да приложим функцията 1 върху 2 3 4, но 1 не е функция. Това е така заради правилото за извикване на функции, първо се оценява първия елемент на списъка (като процедура), а след това и останалите елементи (като аргументи). Това можем да го избегнем, използвайки специалната форма `quote` (с shortcut `'`), която потиска оценяването на даден израз.

```Racket
(1 2 3 4) ; error
'(1 2 3 4) -> fine
```

Какво обаче представляват списъците в Scheme? Можем да дадем индуктивна дефиниция за списък по следния начин:
- празният списък е списък - `'()`
- наредена двойка с първи елемент обект и втори елемент списък е списък

Тоест списъците в Scheme са наредени двойки от "глава" и "опашка" - познатата вече структура едносвързан списък.

Създаването на списък може да се направи по няколко начина:
```Racket
'(1 2 3 4) ; вече го показахме
(cons 1 (cons 2 (cons 3 (cons 4 '())))) ; породено от дефиниция, която дадохме по-горе
(list 1 2 3 4) ; един вид конструктор за създаване на списък
```
Най-често ще използваме `'(1 2 3 4)` тъй като е най-кратко.

Имайки дефиницията за списък, можем да разгледаме как се достъпват елементите на списъка. Щом списъка представлява наредена двойка, то може да се използва `car` и `cdr`
```Racket
(car '(1 2 3 4)) ; 1
(cdr '(1 2 3 4)) ; '(2 3 4)
(car (cdr '(1 2 3 4))) ; 2
(cddddr '(1 2 3 4)) ; '()
```
#### NB! От дефиницията за списък, последния елемент на списък винаги е празният списък. Ако списък не завършва със спразния списък, то това не е списък!

Функции за работа със списъци:
- `(list? x)` - предикат, който ни връща дали x е списък
- `(null? x)` - предикат, който ни връща дали x е празният списък
- `(cons a x)` - връща списък, в който сме добавили нов елемент в началото


Задачи
-------
#### Задача 1
Да се напише функция, която връща елемента на позиция k в даден списък

#### Задача 2
Да се напише функция, която връща дължината на даден списък

#### Задача 3
Да се напише функция, която намира сумата на елементите на даден списък

#### Задача 4
Да се напише функция, която проверява дали елемент x се съдържа в даден списък

#### Задача 5
Да се напише функция, която конкатенира два списъка

#### Задача 6
Да се напише функция, която обръща даден списък

#### Задача 7
Да се напише функция, която взима първите k елемента на даден списък

#### Задача 8
Да се напише функция, която премахва първите k елемента на даден списък

#### Задача 9
Да се напише функция, която приема две естествени числа p и q и списък x и връща списък, съдържащ елементите от списъка x, които са на позиция [p, q)

#### Задача 10
Да се напише функция, която приема предикат p? и списък x и връща нов списък съдържащ само онези елементи на x, които изпълняват предиката p?

#### Задача 11
Да се напише функция, която приема мапваща функция fn и списък x и връща нов списък, състоящ се от елементите на x след прилагане на fn върху всеки един от тях
