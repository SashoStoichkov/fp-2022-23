Седмица 2
=========

Теория:
- Рекурсивни и итеративни процеси
- Вътрешни дефиниции

## Рекурсивни и теративни процеси

Първо да разгледаме какво представлява един рекурсивен процес

```Scheme
(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))
  )
)
```

Нека разгледаме какво ще се случи при `(factorial 6)`:
```Scheme
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 (factorial 0)))))))
(* 6 (* 5 (* 4 (* 3 (* 2 (* 1 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

Умноженията се отлагат докато не се стигне дъното на рекурсията, защото, за да се случи умножението, трябва всички аргументи да са оценени. Така написана, програмата заема допълнителна памет за всяко извикване на `factorial`. Процес, който изглежда по този начин се нарича рекурсивен.

Алтернатива за пресмятане на факториел на число:
```Scheme
(define (fact-iter n product)
  (if (= n 0)
    product
    (fact-iter (- n 1) (* product n))
  )
)
```

Какво се случва при извикването `(fact-iter 6 1)`
```Scheme
(fact-iter 6 1)
(fact-iter 5 6)
(fact-iter 4 30)
(fact-iter 3 120)
(fact-iter 2 360)
(fact-iter 1 720)
(fact-iter 0 720)
720
```

Тук вместо да отлагаме операцията по умножение, запазваме (натруваме) резултата като аргумент на функцията и когато стигнем до дъното на рекурсията (n = 0), връщаме натрупаната стойност, която е запазена във втория аргумент.

Разликата между рекурсивните и итеративните процеси е, че при итеративните процеси избягваме отлагането на операцията, което води до използване на по-малко памет и паметта не нараства с времето. В императивните езици има конструкции познати като цикли, които извършват итерацията - for, while, do-while, foreach. 


## Вътрешни дефиниции
В процедурите можем да си дефинираме и вложени процедури, които да са достъпни единствено в тялото на процедурата, в която са дефинирани.
```Scheme
(define (proc-name ...)
  (define (inner-proc1 ...)
    ...
  )

  (define (inner-proc2 ...)
    ...
  )

  (inner-proc1 (inner-proc2 a b) c d)
)
```

Подобни дефиниции са валидни, тъй като в тялото на една процедура може да имаме неограничен брой изрази, но резултата от изпълнението на процедурата е резултата от последния израз.
Вътрешните дефиниции са полезни, когато имаме процедура, от която се нуждаем само и единствено в изпълнението на самата процедура. 

Пример:
```Scheme
(define (factotial n)
  (define (fact-iter current product)
    (if (= n 0)
      product
      (fact-iter (- current 1) (* product current))
    )
  )
  (fact-iter n 1)
)
```

Тук обличаме итеративният вариант на factorial в друга функция, за да не се налага да подаваме стойност за product, тъй като n! зависи изцяло от n, а началната стойност на product е винаги 1.


Задачи (всички процедури трябва да използват итеративен процес)
-------

### Зад 1
Да се напише процедура, която повдига числото n на степен q

### Зад 2
Да се напише процедура, която намира броя на цифрите на числото n

### Зад 3
Да се напише процедура, която намира сумата на естествените числа в интервала [a, b)

### Зад 4
Да се напише процедура, която намира n-тото число от редицата на Фибоначи

### Зад 5
Да се напише процедура, която обръща числото n на обратно (678 -> 876)

### Зад 6
Да се напише процедура, която намира сбора от цифрите на числото n

### Зад 7
Да се напише процедура, която проверява дали числото n е просто

### Зад 8
Да се напише процедура, която проверява дали цифрите на числото n са в нарастващ ред (Пример: 14579)

### Зад 9
Да се напише процедура, която проверява дали числото n завършва с числото k

### Зад 10
Да се напише процедура, която обръща числото n от десетична в двоична бройна система

### Зад 11
Да се напише процедура, която обръща числото n от двоична в десетична бройна система

