Седмица 1
=========

Теория:
---------

- Въведение в синтаксиса на Scheme 
  - Типове в Scheme
  - Префиксно извикване на процедури
  - Коментари в Scheme
  - Аритметични и логически операции
    - +, -, *, /, quotient, remainder, =
    - and, or, not
  - Дефиниране на символи и процедури
  - Условни конструкции

Имаме няколко вида типове за данните в Scheme

*Основни*: 
  - boolean - #t или #f 
  - number - покрива всички комплексни числа
  - character - записват се чрез #\<символ>

*Комплексни*:
  - Symbols - идентификатори на функции/променливи
  - Strings - Поредица от characters - "Asd"
  
Има и други, които ще разглеждаме в следващите упражнения

Процедурите (функциите) в scheme са префиксни, т.е. вместо a + b записваме (+ a b). Чрез оператора кръгли скоби () извикваме процедура като на първо място слагаме името на процедурата (в примера със събирането, името на процедурата е символа +) и след това изреждаме нейните параметри.

Писането на коментари се случва чрез ; а не както в другите езици чрез // или #

В Scheme се поддържат добре познатите ни аритметични и логически оператори
  - `+` събира случаен брой числа
    - `(+ 1 2) ; 3`
    - `(+ 1 2 3 4 5 6 7) ; 28`

  - `-` от първото число изважда всички останали (приема случаен брой аргументи)
      Пример: 
        - (- 5 1) ; 4 
        - (- 8 1 2 5) ; 0

  - `*` Умножава случаен брой числа
    - `(* 2 3) ; 6`
    - `(* 5 1 3 4) ; 60`

  - `/` Разделя първото число на всички останали (!!! това е дробно деление !!!) (приема случаен брой числа)
      - `(/ 5 2) ; 2 1/2`
      - `(/ 5 2.0) ; 2.5`
      - `(/ 12 2 3) ; 2`

  - `quotient` целочислено деление на две числа (връща само цялата част при делението на a и b)
    - `(quotient 5 2) ; 2`
    - `(quotient 9 3) ; 3`

  - `remainder` връща остатъчка при делението на две числа
    - `(remainder 5 2) ; 1`
    - `(remainder 34 5) ; 4`
    - `(remainder 8 2) ; 0`

  - `=` сравнява два обекта (в Scheme е =, а не ==)
    - `(= 1 5) ; #f`
    - `(= 2 2) ; #t`
  - `and` логическо и
    - `(and #t #f) ; #f`
    - `(and #t #t #t) ; #t`
    - `(and (= 2 2) (= 3 2)) ; #f`
  - `or` логическо или
    - `(or #t #f) ; #t`
    - `(or #f #f #f) ; #f`
    - `(or (= 2 2) (= 3 2)) ; #t`
  - `not` логическо отрицание
    - `(not #t) ; #f`
    - `(not #f) ; #t`
    - `(not (and (= 2 2) (= 3 2))) ; #t`

Дефинирането на символи в scheme се случва чрез вградената процедура `define`. Тя приема символ и стойност и свързва символа със стойността

    (define name "Pesho")
    name ; Pesho

Чрез define можем да си дефинираме и наши процедури като синтаксиса за това е

    (define (proc-name arg1 arg2 ...)
      (proc-body)
    )
Пример:

    (define (sum a b)
      (+ a b)
    )

В Scheme имаме два вида условни конструкции if и cond
  - `(if condition result-true result-false)` - действа по същия начин както и тернарния оператор в императивните езици. Израза подаден на мястото на condition се оценява до `#t` или `#f` и според оценката се връща една от стойностите `result-true` или `result-false`
  - `(cond
       (condition1 result1)
       (condition2 result2)
       ...
       (else result-else))` - доста сходно с познатата switch конструкцията с една разлика. Изразите се оценяват от горе надолу и резултата от изпълнението на cond е резултата за първият condition, който се е оценил до true. Ако нито един condition не се оцени до true се връща резултата от else.

Задачи
--------------------------
### Зад 1
Да се преобразуват следните изрази в синтаксис на Scheme:

  `5 * 3 / 2 - (8 + 3)^5 - 4`
  
  `a && b || !c && (a || d)`

### Зад 2
Да се напише процедура, която връща дали n е четно или нечетно

### Зад 3
Да се напише процедура, която повдига числото n на степен q

### Зад 4
Да се напише процедура, която смята n!

### Зад 5
Да се напише процедура, която пресмята n-тото число на фибоначи

### Зад 6
Да се напише процедура, която намира сбора на числата в интервала [a, b)

### Зад 7
Да се напише процедура, която намира броят на цифрите на числото n

### Зад 8
Да се напише процедура, която намира броят на срещанията на цифрата p в числото n

### Зад 9
Да се напише процедура, която обръща числото n на обратно (Пример: 789 -> 987)

### Зад 10
Да се напише процедура, която проверява дали дадено число е палиндром
