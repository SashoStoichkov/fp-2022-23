# Упражнение 2

## Вложени дефиниции

### define

```scheme
;; пример от Упражение 1
;; решава 3x^2 + 2x - 1 = 0
;; (define (root? x)
;;   (= 0 (+
;;          (* 3 (expt x 2))
;;          (* 2 x)
;;           -1)))

;; може да вложим множество дефиниции
;; в тялото на фукнцията
(define (root? x)
  (define a (* 3 (expt x 2)))
  (define b (* 2 x))
  (define c -1)
  (define fx (+ a b c))
  
  (= 0 fx))
```

### let (успоредно свързване)

```scheme
;; използваме let за локално свързване на 
;; оценки със символи - променливите, дефинирани в let израза, 
;; са видими само в тялото му

;; често използваме let когато искаме да си 
;; "спестим" повторни изчисления

;; първо се изчисляват всички value изрази (отдясно)
;; и след това оценката на всеки от тях се свързва
;; със съответствашия му variable символ (отляво)
(let
    ((variable1 value1)
     (variable2 value2)
     ;; ...
     (variablen valuen))
  body)

(define (root? x)
  (let ((a (* 3 (expt x 2)))
        (b (* 2 x))
        (c -1))
    (= 0 (+ a b c))))
```

### let* (последователно свързване)

```scheme
;; какво ще се случи ако към горния пример
;; добавим още една променлива?

;; (define (root? x)
;;   (let ((a (* 3 (expt x 2)))
;;         (b (* 2 x))
;;         (c -1)
;;         (fx (+ a b c)))
;;     (= 0 fx)))
;; => a: unbound identifier

;; value изразите се изчисляват и свързват 
;; със съответстващите им variable символи 
;; последователно от ляво надясно

;; променливите, дефинирани в let* израза, са 
;; видими от дефиницията си до края на let израза
(define (root? x)
  (let* ((a (* 3 (expt x 2)))
         (b (* 2 x))
         (c - 1)
         (fx (+ a b c)))
    (= 0 fx)))

;; горната дефиниция е еквивалентна на
;; (define (root? x)
;;   (let ((a (* 3 (expt x 2))))
;;     (let ((b (* 2 x)))
;;       (let ((c -1))
;;         (let ((fx (+ a b c)))
;;           (= 0 fx))))))
```

## Рекурсивни и итеративни процеси

### (Същински) Рекурсивни процеси  

Генерирани от функции, в които има отложени операции.

```scheme
(define (factorial number)
    (if (< number 2)
        1
        (* number (factorial (- number 1)))))

;; как изглежда развитието на функцията
;; когато я извикаме с аргумент 4
;; > (factorial 4)

;; (* 4 (factorial 3))
;; (* 4 (* 3 (factorial 2)))
;; (* 4 (* 3 (* 2 (factorial 1))))
;; (* 4 (* 3 (* 2 1)))
;; (* 4 (* 3 2))
;; (* 4 6)
;; 24

;; умноженията се отлагат докато не достигнем дъното
;; на рекурсията, когато всички аргументи са оценени
```

## Итеративни процеси  

Рекурсивно извикване, при което няма отложена операция се нарича опашкова рекурсия.  
Функциите, в които всички рекурсивни извиквания са опашкови, генерират итеративни процеси.

```scheme
(define (factorial number)
  (define (fact-iter product counter)
    (if (> counter number)
        product
        (fact-iter (* counter product) (+ counter 1))))
                   
  (fact-iter 1 1))

;; как изглежда развитието на функцията
;; когато я извикаме с аргумент 4
;; > (factorial 4)

;; (fact-iter  1 1)
;; (fact-iter  1 2)
;; (fact-iter  2 3)
;; (fact-iter  6 4)
;; (fact-iter 24 5)
;; 24

;; при итеративните процеси липсва етап на
;; свиване на рекурсията; опашковата рекурсия
;; се използва за симулиране на цикли

;; на всяка стъпка пазим само константен брой стойности:
;; - product - натрупваме/акумулираме резултата,
;; който функцията ще върне
;; - counter - брояч
```
---

## Задачи

1. Дефинирайте функция `(sum-interval a b)`, която смята сумата на числата в челочисления интервал $[a,b]$.  
Използвайте итеративен процес.

    ```scheme
    > (sum-interval 1 3) => 6
    ```  

2. Дефинирайте функция `(power base exponent)`, която смята $base^{exponent}$, където $exponent$ е цяло число.  
Използвайте итеративен процес.

3. Дефинирайте функция `(sum-digits number)`, която смята сумата от цифрите на числото $number$.
    ```scheme
    > (sum-digits 123) => 6
    ```  

4. Дефинирайте функция `(reverse-digits number)`, която обръща последователността на цифрите на дадено естествено число.  
Използвайте итеративен процес.
    ```scheme
    > (reverse-digits 123) => 321
    ```
  
5. Дефинирайте функция `(count-divisors number)`, която връща броя на делителите на числото $number$  
    ```scheme
    > (count-divisors 6) => 4 ; делителите на 6 са 1,2,3,6
    ```

6. Дефинирайте предикат `(prime? number)`, който определя дали $number$ е просто число  

7. Дефинирайте предикат `(increasing-digits? number)`, който определя дали цифрите в записа за числото $number$ са подредени във възходящ ред
    ```scheme
    > (increasing-digits 123) => #t
    > (increasing-digits 132) => #f
    ```

8. Дефинирайте функция `(binary-to-decimal number)`, която по дадено число в двоична бройна система, връща същото число в десетична бройна система
    ```scheme
    > (decimal-to-binary 101) => 5
    ```
    
9. Дефинирайте функция `(decimal-to-binary number)`, която по дадено число в десетична бройна система, връща същото число в двоична бройна система
    ```scheme
    > (decimal-to-binary 5) => 101
    ```

    ![Decimal to Binary](https://d138zd1ktt9iqe.cloudfront.net/media/seo_landing_files/decimal-to-binary-conversion-1623818593.png)